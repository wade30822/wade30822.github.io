
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>朱家骅的Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="朱家骅">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="朱家骅的Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="朱家骅的Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朱家骅的Blog">
<meta name="twitter:description">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="朱家骅的Blog">朱家骅的Blog</a></h1>
				<h2 class="blog-motto">把流行的技术挂在嘴边，不如把过时的技术记在心里</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/13/译-java多线程与同步机制系列(终结篇)/" title="[译]java多线程与同步机制系列(终结篇)" itemprop="url">[译]java多线程与同步机制系列(终结篇)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-13T00:54:20.000Z" itemprop="datePublished"> 发表于 2015-05-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接-1(<a href="http://tutorials.jenkov.com/java-concurrency/amdahls-law.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/amdahls-law.html</a>)</p>
<p>原文链接-2(<a href="http://tutorials.jenkov.com/java-concurrency/references.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/references.html</a>)</p>
<p>译者注：该系列最后两篇作者讲到了阿姆达尔定律以及推荐的java多线程的书籍，这里就不详细翻译了，详细的内容可以点击链接查看。</p>
<p>至此，整个Java多线程与同步机制系列就已经翻译完毕了，我从中也学习了很多关于多线程的知识，接下来我的计划是了解多线程的框架并利用这些框架开发应用，因为知识学得再多但是不去实践的话，过不了多久就会忘记，所以实践非常重要。</p>
<p>关于作者推荐的书单，我推荐如下几本，第一本是非常经典的Java多线程入门书籍，这本书讲得浅显易懂，涵盖了本系列的所有知识，但缺点是这本书太老了。第二本则是对几种常见java多线程架构的介绍，并且这本书是2014年出版的，因此讲的内容非常新，但是缺点就是只有英文版，不过读起来也不会费劲。下面给出了这两本书的介绍:</p>
<p><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/" target="_blank" rel="external">Java Concurrency in Practice</a></p>
<p>This is the newest book on Java concurrency. It is from 2006 so it is a bit dated in some ways. For instance, it does not cover asynchronous architectures much (which are getting popular now in 2015). It is a decent book on Java concurrency. By far the best book on the <a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="external">java.util.concurrent package in Java 5 and forward</a>.</p>
<p><a href="http://www.amazon.com/Seven-Concurrency-Models-Weeks-Programmers/dp/1937785653/" target="_blank" rel="external">Seven Concurrency Models in Seven Weeks</a></p>
<p>This book is newer (from 2014) and covers different concurrency models - not just the traditional Threads, Shared Memory and Locks model.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/13/译-java多线程与同步机制系列(终结篇)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/13/译-java多线程与同步机制系列(终结篇)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/12/译-java多线程与同步机制系列(27)/" title="[译]java多线程与同步机制系列(27)--非阻塞算法" itemprop="url">[译]java多线程与同步机制系列(27)--非阻塞算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-12T01:57:08.000Z" itemprop="datePublished"> 发表于 2015-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html</a>)</p>
<p>多线程同步领域的非阻塞算法的作用是使多个线程访问共享资源时不会发生阻塞，通俗一点讲就是一个线程的阻塞不会导致其他线程的阻塞。</p>
<p>为了更好的理解阻塞算法和非阻塞算法，我将首先讲解阻塞算法最后讲解非阻塞算法。<br><br></p>
<h3 id="阻塞同步算法">阻塞同步算法</h3><p>阻塞同步算法会使某个线程执行操作并且阻塞另外一个尝试执行同样操作的线程。大部分同步算法和同步数据结构都是阻塞的，比如说<a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="external">java.util.concurrent.BlockingQueue</a>接口的不同实现类全部都是阻塞数据结构，如果一个线程尝试向队列中插入数据，但是当前队列是满的，那么线程将被阻塞直到队列空出了空间存放数据。</p>
<p>下图显示了阻塞同步算法应用在共享数据结构的行为：</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-1.png" alt="阻塞同步算法应用于共享数据结构"></p>
<h3 id="非阻塞同步算法">非阻塞同步算法</h3><p>非阻塞同步算法使得某个线程执行操作不会阻塞尝试执行相同操作的线程，当前执行线程会通知其他线程当前无法执行操作。Java提供了很多非阻塞的数据结构，比如<a href="http://tutorials.jenkov.com/java-util-concurrent/atomicboolean.html" target="_blank" rel="external">AtomicBoolean</a>,<a href="http://tutorials.jenkov.com/java-util-concurrent/atomicinteger.html" target="_blank" rel="external">AtomicInteger</a>,<a href="http://tutorials.jenkov.com/java-util-concurrent/atomiclong.html" target="_blank" rel="external">AtomicLong</a>.</p>
<p>下图显示了非阻塞算法应用在共享数据结构的行为:</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-2.png" alt="非阻塞同步算法应用于共享数据结构"></p>
<h3 id="非阻塞算法_VS_阻塞算法">非阻塞算法 VS 阻塞算法</h3><p>非阻塞算法与阻塞算法的最大不同在于阻塞算法会阻塞其他线程而非阻塞算法将通知其他线程操作不可执行。</p>
<p>阻塞算法会阻塞线程直到该线程请求的操作可以执行。通常一个线程执行请求的操作需要其他线程执行相关的操作，一旦由于某些原因其他线程被阻塞的话，那么该线程也将一直被阻塞直到其他线程最终启动执行必要的操作。比如说线程A向一个满的阻塞队列中插入数据时会发生阻塞直到其他线程从该队列中取出数据。如果由于某些原因其他线程被阻塞了，那么线程A将一直保持阻塞直到其他线程最终从该队列中提取数据。<br><br></p>
<h3 id="非阻塞同步数据结构">非阻塞同步数据结构</h3><p>在多线程系统中，线程间都是通过一些数据结构进行通信。这些数据结构包括简单的数据类型和复杂数据结构如queues，maps，stacks等等。为了使多个线程能正确，同步的访问这些数据结构，那么它们就必须被同步算法守护，而这些同步算法就使得该数据结构成为了同步数据结构。</p>
<p>如果守护算法会使线程阻塞的话，那么该算法就是阻塞算法，该数据结构就是阻塞同步数据结构。</p>
<p>如果守护算法不会使线程阻塞的话，那么该算法就是非阻塞算法，该数据结构就是非阻塞同步数据结构。</p>
<p>每一个同步数据结构都支持特定的线程通信方式，采用哪一种同步数据结构取决于具体的需求。接下来我将介绍几种非阻塞同步数据结构以及它们的应用场景，通过讲解这些非阻塞数据结构的工作机制可以让你了解它们的设计和实现原理。<br><br></p>
<h3 id="Volatile变量">Volatile变量</h3><p>volatile变量将使线程直接从主存中读取该变量的值，当一个新值被赋给该变量时，那么这个新值将直接写到主存中。这就保证该变量的最新值对于其他线程是可见的，其他线程将直接从主存读取该变量的值而不是从CPU寄存器或CPU缓存中读取。</p>
<p>Volatile变量是非阻塞的，对该变量的赋值是原子操作即无法被打断。但是对volatile变量的read-update-write操作却不是原子性的。因此如果有多个线程执行这个操作时就会发生竞争:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volatile <span class="variable">myVar =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">int <span class="variable">temp =</span> myVar;</span><br><span class="line">temp++;</span><br><span class="line"><span class="variable">myVar =</span> temp;</span><br></pre></td></tr></table></figure>
<p>首先myVar的值从主存中读取并把值赋给了temp变量，然后temp加1，最后temp的值赋给myVar意味着这个新值被立即写到主存中的myVar变量上。</p>
<p>如果两个线程执行上述代码的话，两个线程同时读取myVar的值，分别赋给该线程的temp变量，然后temp加1并将新值写入主存中，那么现在myVar的新值可能就是1而不是2了。</p>
<p>你可能会说你不会写出这种代码，但是你要注意上面的代码与下面这句代码是等效的:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">myVar</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当执行上面这句代码时，myVar的值被加载到CPU缓存或者寄存器中，然后执行加1操作并将新值写入主存中。<br><br></p>
<h4 id="单写线程的例子">单写线程的例子</h4><p>在某些情况下对于某个共享数据只有一个写线程和多个读线程，那么当写线程更新该数据并且多个读线程读取该数据就不会发生竞争。在这种情况下你可以使用volatile变量。</p>
<p>竞争只会发生在多个线程对同一个共享对象执行read-update-set操作，如果你只有一个线程执行该操作，其他线程都只是读取该共享对象的值的话就不会发生竞争。</p>
<p>下面是一个Counter类，它没有使用同步块但仍然是同步的因为只有一个写线程对其执行更新计数操作：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">SingleWriterCounter</span> &#123;</span><br><span class="line"></span><br><span class="line">    private volatile long count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Only</span> one thread may ever call this <span class="keyword">method</span>,</span><br><span class="line">     * <span class="keyword">or</span> it will lead to race conditions.</span><br><span class="line">     */</span><br><span class="line">    public <span class="type">void</span> inc() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Many</span> reading threads may call this <span class="keyword">method</span></span><br><span class="line">     * @<span class="keyword">return</span></span><br><span class="line">     */</span><br><span class="line">    public long count() &#123;</span><br><span class="line">        <span class="keyword">return</span> this.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程同时访问这个counter类对象，但其中只有一个线程调用inc方法。这里的一个线程指的是同一个线程，多个线程可以同时调用count方法，这种情况不会发生竞争。</p>
<p>下图显示了多个线程如何操作该counter对象：</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-3.png" alt="多个线程操作counter对象"></p>
<h4 id="更多基于volatile变量的复杂数据结构">更多基于volatile变量的复杂数据结构</h4><p>我们也可以创建包含多个volatile变量的数据结构，其中每个volatile变量只准被同一个线程修改但可以被多个线程读取，这里的同一个线程是指每个volatile变量都可以被一个不同的线程修改，比如说A变量可以被线程1修改且只允许被线程1修改。使用这种数据结构就允许多个线程以非阻塞方式执行。</p>
<p>下面的Counter类就允许多个写线程执行：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">DoubleWriterCounter</span> &#123;</span><br><span class="line"></span><br><span class="line">    private volatile long countA = <span class="number">0</span>;</span><br><span class="line">    private volatile long countB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Only</span> one (<span class="keyword">and</span> the same <span class="keyword">from</span> thereon) thread may ever call this <span class="keyword">method</span>,</span><br><span class="line">     * <span class="keyword">or</span> it will lead to race conditions.</span><br><span class="line">     */</span><br><span class="line">    public <span class="type">void</span> incA() &#123; this.countA++;  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Only</span> one (<span class="keyword">and</span> the same <span class="keyword">from</span> thereon) thread may ever call this <span class="keyword">method</span>,</span><br><span class="line">     * <span class="keyword">or</span> it will lead to race conditions.</span><br><span class="line">     */</span><br><span class="line">    public <span class="type">void</span> incB() &#123; this.countB++;  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Many</span> reading threads may call this <span class="keyword">method</span></span><br><span class="line">     */</span><br><span class="line">    public long countA() &#123; <span class="keyword">return</span> this.countA; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="type">Many</span> reading threads may call this <span class="keyword">method</span></span><br><span class="line">     */</span><br><span class="line">    public long countB() &#123; <span class="keyword">return</span> this.countB; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，DoubleWriterCounter类有两个volatile变量以及两对inc方法和count方法。这里只允许一个线程调用incA方法，一个线程调用incB方法。这样该类就允许两个线程同时调用incA和incB方法，其他线程调用countA和countB方法，这不会引起竞争。</p>
<p>这个DoubleWriterCounter类可以用于两个线程之间的通信。countA和countB可以表示任务的产生和执行数量。下图显示了两个线程如何利用DoubleWriterCounter类进行交互:</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-4.png" alt="线程交互"></p>
<p>细心的读者可能会发现DoubleWriterCounter类的功能也可以由两个SingleWriterCounter来实现。你可以根据你的需求使用任意数量的SingleWriterCounter。<br><br></p>
<h3 id="基于乐观锁的CAS">基于乐观锁的CAS</h3><p>如果现在有多个线程需要对共享对象进行写操作，则单纯依靠volatile变量就不可行。你可能需要对变量的访问进行控制，做法是使用synchronized同步块:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SynchronizedCounter &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> inc() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">count</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="keyword">count</span>() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到inc方法和count方法都是同步方法，但是我们希望避免使用synchronized关键字和wait-notify方法。在这里我们可以采用java提供的原子变量，现在我们就用AtomicLong来改写上面的Counter类:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong <span class="keyword">count</span> = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> inc() &#123;</span><br><span class="line">        <span class="keyword">boolean</span> updated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!updated)&#123;</span><br><span class="line">            <span class="keyword">long</span> prevCount = <span class="keyword">this</span>.<span class="keyword">count</span>.get();</span><br><span class="line">            updated = <span class="keyword">this</span>.<span class="keyword">count</span>.compareAndSet(prevCount, prevCount + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="keyword">count</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">count</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的Counter相比上一个版本来说是线程安全的。这个版本中我们感兴趣的是inc方法的实现，inc方法没有使用synchronized同步块，而是如下几行代码:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> updated = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!updated)&#123;</span><br><span class="line">    <span class="keyword">long</span> prevCount = <span class="keyword">this</span>.<span class="keyword">count</span>.get();</span><br><span class="line">    updated = <span class="keyword">this</span>.<span class="keyword">count</span>.compareAndSet(prevCount, prevCount + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面几行不是原子操作，这就意味着可以有两个不同的线程同时调用inc方法并且执行long preCount = this.count.get()方法，这样两个线程都获取了当前count的值，现在还没有发生竞争。</p>
<p>秘密就在while循环的第二行，compareAndSet方法是一个原子方法，它比较当前值和期望值，如果两个值相等，则将新值赋给count对象。compareAndSet方法就是典型的被CPU CAS指令直接支持的方法，因此在这里没有必要使用同步算法并且没有线程会被阻塞，这就降低了线程阻塞造成的性能损失。</p>
<p>假设当前count值为20，现在两个线程同时获取了该count值并且调用compareAndSet(20,20+1)，由于compareAndSet方法是原子方法，那么两个线程将相继执行该方法。</p>
<p>首先第一个线程将比较当前值(20)是否与期望值(20)相等,很显然现在确实相等，所以count被赋予了新值21并且updated设置为true，该线程退出while循环。</p>
<p>现在第二个线程调用compareAndSet(20,21),由于现在count的当前值是21了，所以这个调用会失败，updated依然为false，那么循环继续。下一次循环中第二个线程重新获取count的值为21，现在它将再次调用compareAndSet(21,22)，现在调用就会成功，并且count的值变为22，如果没有其他线程调用inc方法的话，count的最终值将为22.<br><br></p>
<h4 id="为什么叫做乐观锁">为什么叫做乐观锁</h4><p>上一节中的代码就叫做乐观锁，乐观锁与传统的锁机制不同，它有时候也叫做悲观锁。传统的锁会通过同步块或者其他锁方法而使线程阻塞。乐观锁就允许所有线程获得共享对象的拷贝而不会发生阻塞，随后线程对拷贝对象做修改随后尝试将修改后的新值写回到共享对象中去。如果现在没有其他贤臣对该对象做出修改，那么该修改线程可以通过CAS操作将新值写回到共享对象中，如果其他线程已经对对象做出了修改的话，那么该线程就将获得一份新的拷贝，然后对拷贝作出修改并重新写回到对象中去。</p>
<p>之所以叫做乐观锁是因为每个线程都获得了共享对象的一份拷贝并对其做出修改，然后将其写回到共享对象上去。基于没有其他线程对对象做出修改这个乐观假设，如果这个假设成立，则线程可以将修改写回到对象中，如果假设不成立，则整个操作作废，但是却没有线程被阻塞。</p>
<p>乐观锁适用于在共享对象上有较低或中等的争议点的情形。如果争议点很多的话线程就会花费大量的CPU时间和内存获取共享对象的拷贝并对其做出修改，但是由于争议点很多使得此次修改无法写回到共享对象上。所以在使用乐观锁时，如果共享对象上有很多争议点的话我们应该想办法减少争议点。<br><br></p>
<h4 id="乐观锁是非阻塞的">乐观锁是非阻塞的</h4><p>上面所讲的乐观锁是非阻塞的。如果一个线程获取了共享对象的拷贝并且在修改对象值的时候被阻塞了，但不会影响其他线程访问共享对象。</p>
<p>在传统的上锁/解锁实例中，一个线程获取了某对象的锁后其他试图访问该对象的线程都会被阻塞，如果持有该对象锁的线程被阻塞的话，那么其他线程将一直被阻塞下去，有可能是永久阻塞。<br><br></p>
<h3 id="非可交换数据结构">非可交换数据结构</h3><p>简单的CAS乐观锁适合于共享对象可以被一个新的值交换的情况。但是有时候交换整个共享对象的数据结构不切实际并且缺乏灵活性。</p>
<p>想像一下共享对象是一个队列的话，每个线程如果想对队列中某个数据进行修改的话都将获取一份完整的队列的拷贝然后对拷贝做相应的修改。这可以通过AtomicReference来实现，首先获取这个reference，然后拷贝整个队列并做出修改，然后将reference引用指向新创建的队列。</p>
<p>然而，一个很大的数据结构的拷贝需要大量的内存和CPU时间，这将使你的程序消耗大量的计算机资源，如果数据结构上的争议点很多的话问题更严重。更要命的是，线程拷贝和修改对象的时间越长，那么其他线程已经对该对象做出修改的可能性就越高，这样线程的拷贝以及修改就全部作废并需要重新拷贝新的数据，这将大大增加程序的内存和CPU消耗。</p>
<p>下一章将介绍一种实现非阻塞数据结构的方法可以使得线程同步更新而不仅仅是拷贝和修改。<br><br></p>
<h3 id="共享目标修改对象(Sharing_Intended_Modifications)">共享目标修改对象(Sharing Intended Modifications)</h3><p>现在线程不会拷贝和修改整个共享对象，而是会共享关于共享对象的目标修改对象。那么线程想对共享对象做出修改的话就按照如下流程：</p>
<ol>
<li>检查是否有其他对象对共享对象提交了目标修改</li>
<li>如果没有的话，创建一个目标修改(就是一个普通对象),然后调剂这个目标修改给共享对象(通过CAS操作)</li>
<li>在共享对象上实施目标修改</li>
<li>移除该目标修改对象的引用来向其他线程发送信号表示对象已执行修改。</li>
</ol>
<p>正如你所看见的，第二步将阻塞其他线程提交目标修改对象，也就相当于对共享数据结构上锁。如果一个线程提交了目标修改对象的话，其他线程只能等到第一个提交的目标修改对象被执行才能提交目标修改对象。</p>
<p>如果一个线程提交了目标修改对象后在执行修改操作时被阻塞的话，共享数据结构就被上锁了。共享的数据结构不会直接阻塞线程，线程检测到它们不能提交目标修改时可以执行其他操作，很显然这是我们需要完善的地方。<br><br></p>
<h4 id="可完成的目标修改对象">可完成的目标修改对象</h4><p>为了防止提交的目标修改阻塞共享数据结构，目标修改必须包含足够的信息给其他线程来完成修改。因此如果提交了目标修改对象的线程没有完成修改的话，其他线程可以代表它继续完成修改并且使得共享对象可以继续被其他线程使用。</p>
<p>下图描述了上面描述的非阻塞算法:</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-5.png" alt="非阻塞算法"></p>
<p>修改必须由一个或多个CAS操作来完成，如果两个线程试图在共享对象上实施目标修改的话，只有一个线程可以执行CAS操作来执行修改，而第一个线程执行修改完成后另一个线程尝试执行CAS操作的话就会失败。<br><br></p>
<h3 id="A-B-A问题">A-B-A问题</h3><p>上面的算法会导致A-B-A问题，意思是变量的值从A变为B又变回了A，其他线程察觉不到这个变化。</p>
<p>比如线程A检查当前正在执行的修改，如果当前没有修改的话线程A将拷贝数据，此时线程调度器暂停了线程A的执行并开启线程B，那么线程B此时也可以拷贝相同的数据，并对该数据结构执行了一次完整的修改，最后移除了对目标修改对象的引用。随后线程A继续执行，但是线程B对数据的修改没有通知到线程A，线程A认为数据没有被修改，但数据已经被线程B修改过了，此时线程A所拷贝的数据已经过时了，所以线程A的执行结果会覆盖线程B的执行结果。</p>
<p>下图显示了A-B-A问题的场景:</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-6.png" alt="A-B-A问题"></p>
<h4 id="A-B-A问题的解决方式">A-B-A问题的解决方式</h4><p>解决A-B-A问题的通用方法是不仅仅只交换目标修改对象的指针，而是将指针与一个计数器相结合，这样即使目标修改对象的指针归位，但是计数器的值不为0则表示数据已经被修改了，这样可以使这次修改对其他线程可见。</p>
<p>在java中提供了<a href="http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.html" target="_blank" rel="external">AtomicStampedReference</a>类，该类可以利用CAS操作交换一个引用和一个版本戳。<br><br></p>
<h3 id="一个非阻塞算法的示例">一个非阻塞算法的示例</h3><p>下面就是一个非阻塞算法的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonblockingTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntendedModification</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> AtomicBoolean completed =</span><br><span class="line">                <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicStampedReference&lt;IntendedModification&gt;</span><br><span class="line">        ongoingMod =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;IntendedModification&gt;(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//declare the state of the data structure here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!attemptModifyASR());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptModifyASR</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        IntendedModification currentlyOngoingMod =</span><br><span class="line">        ongoingMod.getReference();</span><br><span class="line">        <span class="keyword">int</span> stamp = ongoingMod.getStamp();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(currentlyOngoingMod == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//copy data structure state - for use</span></span><br><span class="line">            <span class="comment">//in intended modification</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//prepare intended modification</span></span><br><span class="line">            IntendedModification newMod =</span><br><span class="line">            <span class="keyword">new</span> IntendedModification();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">boolean</span> modSubmitted = </span><br><span class="line">                ongoingMod.compareAndSet(<span class="keyword">null</span>, newMod, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(modSubmitted)&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//complete modification via a series of compare-and-swap operations.</span></span><br><span class="line">                <span class="comment">//note: other threads may assist in completing the compare-and-swap</span></span><br><span class="line">                <span class="comment">// operations, so some CAS may fail</span></span><br><span class="line">            </span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//attempt to complete ongoing modification, so the data structure is freed up</span></span><br><span class="line">            <span class="comment">//to allow access from this thread.</span></span><br><span class="line">        </span><br><span class="line">            modified = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="非阻塞算法实现困难">非阻塞算法实现困难</h3><p>非阻塞算法很难设计与实现，在尝试自己设计非阻塞算法前可以先去搜索一下是否有人已经实现了正确的非阻塞算法。Java提供了很多非阻塞算法的实现，比如CocurrentLinkedQueue，以后也会提供更多的非阻塞算法的实现。</p>
<p>除了java提供的算法实现，其他第三方也提供了很多非阻塞的算法实现，比如LMAX Disruptor。更多介绍可以参考<a href="http://tutorials.jenkov.com/java-concurrency/references.html" target="_blank" rel="external">Java concurrency references page</a>这篇博客。<br><br></p>
<h3 id="非阻塞算法的优点">非阻塞算法的优点</h3><p>非阻塞算法有很多的优点，下面重点讲一下以下几个优点。</p>
<h4 id="选择">选择</h4><p>非阻塞算法的第一个优点是当请求执行操作的线程被拒绝操作时它可以去执行其他操作，而不是阻塞等待。当然有时候该线程没有其他操作可以执行，这种情况下它可以选择阻塞和等待并将CPU让给其他线程运行。</p>
<p>在单CPU系统中，将操作被拒绝的线程阻塞并让其他线程运行是很有意义的。但是即使在单CPU系统中阻塞算法也会导致死锁，饥饿以及其他同步问题。</p>
<h4 id="无死锁">无死锁</h4><p>非阻塞算法的第二个好处是不会发生死锁的情况，两个线程不会等待对方释放自己想获取的锁而阻塞，因为线程压根就不会被阻塞即使它们无法执行期望的操作。但是非阻塞算法会导致活锁即两个线程持续尝试执行操作，但是一直被告知操作无法执行(由于其他线程的操作)。</p>
<h4 id="无线程阻塞">无线程阻塞</h4><p>阻塞和唤醒线程的代价是很大的，即使随着操作系统和线程库的优化使得代价相比以前降低了不少。</p>
<p>当一个线程被阻塞时，随之而来的就是线程的唤醒。非阻塞算法中线程不会被阻塞也就不会发生线程的唤醒。这就意味着CPU可以执行更多的逻辑操作而不是把时间都花在上下文切换。</p>
<p>在多CPU系统中阻塞算法对程序整体性能影响很大。如果运行在CPU A上的线程等待CPU B上的线程而阻塞的话，则程序整体的并行性就降低。当然此时CPU A可以运行其他线程，但是上下文切换的代价非常高，所以线程阻塞发生的越少越好。</p>
<h4 id="降低线程延迟">降低线程延迟</h4><p>延迟指的是线程发出操作的请求到线程真正执行该操作之间的时间间隔，由于非阻塞算法中线程不会被阻塞所以线程不用考虑这一延迟，这就意味着当线程发起的请求被允许的话就会立刻执行。</p>
<p>非阻塞算法是通过忙等待来降低延迟。当然如果在非阻塞同步数据结构上有很多争议点的话，忙等待会消耗大量的CPU执行时间，这是我们需要注意的地方。当数据结构上有很多争议点的话非阻塞算法可能不是一个好的解决方案，但是我们可以重新设计程序来减少争议点。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/12/译-java多线程与同步机制系列(27)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/12/译-java多线程与同步机制系列(27)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/11/译-java多线程与同步机制系列(26)/" title="[译]java多线程与同步机制系列(26)--同步块的内部组成" itemprop="url">[译]java多线程与同步机制系列(26)--同步块的内部组成</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-11T00:21:53.000Z" itemprop="datePublished"> 发表于 2015-05-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html</a>)</p>
<p>即使很多同步块结构(locks,semophore,blocking queue)在功能上有区别,但是它们的内部设计却没有太大的区别，换句话说就是它们内部有很多相同或相似的组织结构。本文将重点讲解这些相同或相似的组织结构，了解这些组织结构对我们今后实现自定义的同步块结构很有帮助。</p>
<p>大多数的同步块的目的是为了守护临界区以防止多个线程访问该临界区造成混乱。为了保证这一点一般同步块都包含以下几个组成部分:</p>
<ol>
<li>State(状态)</li>
<li>Access Condition(判断条件)</li>
<li>State Changes(状态变换)</li>
<li>Notification Strategy(通知策略)</li>
<li>Test And Set Method(先判断后设置方法)</li>
<li>Set Method(设置方法)</li>
</ol>
<p>并不是所有的同步块就必须要具有以上所有的组成部分，有些同步块只需要具备以上某些组成部分就能实现该同步块的功能<br><br></p>
<h3 id="State">State</h3><p>同步块中的state是被Access Condition用来判断线程是否允许获取访问权限的。在<a href="http://tutorials.jenkov.com/java-concurrency/locks.html" target="_blank" rel="external">Lock</a>中，state被保存在一个boolean变量中代表lock对象是否已被上锁。在<a href="http://tutorials.jenkov.com/java-concurrency/semaphores.html#bounded" target="_blank" rel="external">Bounded Semaphore</a>中，state被保存在了一个计数器(int)和上边界(int)中分别表示该信号被发射的次数和最大次数。在<a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html" target="_blank" rel="external">Blocking Queue</a>中，state被保存在了一个等待队列以及队列最大长度两个变量中。</p>
<p>下面两个代码块取自Lock和BoundedSemaphore，其中的状态代码以注释标记:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//state is kept here</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//state is kept here</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bound = upperBound;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</span><br><span class="line">    <span class="keyword">this</span>.signal++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Access_Condition">Access Condition</h3><p>Access Condition是用来判断一个线程执行test and set方法是否被允许，它是基于同步块中的state来作判断的。access condition通常在while循环中来进行判断以防止<a href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html#spuriouswakeups" target="_blank" rel="external">Spurious Wakeups</a>,它的判断结果非真即假。</p>
<p>在<a href="http://tutorials.jenkov.com/java-concurrency/locks.html" target="_blank" rel="external">Lock</a>中，access condition只需要判断isLocked变量的值即可。在<a href="http://tutorials.jenkov.com/java-concurrency/semaphores.html#bounded" target="_blank" rel="external">Bounded Semaphore</a>中有两个access condition，它们的使用取决于线程是发送信号还是接收信号，如果是发送信号的话就判断signals变量的值是否小于upper bound的值，如果是接收信号的话就判断signals变量的值是否不等于0.</p>
<p>下面两个代码块取自Lock和BoundedSemaphore，其中access condition以注释标记，注意判断都是在while循环中进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">//access condition</span></span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bound = upperBound;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">//access condition</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</span><br><span class="line">    <span class="keyword">this</span>.signals++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">//access condition</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</span><br><span class="line">    <span class="keyword">this</span>.signals--;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="State_Changes">State Changes</h3><p>一旦线程被允许进入临界区的话，那么它就可能会改变state的值来防止其他线程进入临界区。换句话说就是state是用来反映当前已经有一个线程在临界区内执行了，这个state的值将影响其他线程的access condition。</p>
<p>在<a href="http://tutorials.jenkov.com/java-concurrency/locks.html" target="_blank" rel="external">Lock</a>中，state change是将isLocked设置为true，在Semaphore中是signals++和signals—。</p>
<p>下面两个代码段取自Lock和BoundedSemaphore，state change以注释标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    isLocked = <span class="keyword">false</span>;</span><br><span class="line">    notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bound = upperBound;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    <span class="keyword">this</span>.signals++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    <span class="keyword">this</span>.signals--;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Notification_Strategy">Notification Strategy</h3><p>一旦线程改变了同步块中某个状态(State Changes)，有时候它需要唤醒其他等待线程，这次的状态变换可能会使其他线程的access condition判断为true。</p>
<p>Notification Strategy包含以下三个形式：</p>
<ol>
<li>唤醒所有等待线程</li>
<li>随机唤醒所有等待线程中的一个</li>
<li>唤醒特定的一个等待线程</li>
</ol>
<p>唤醒所有线程非常简单。线程调用wait方法进入等待状态，一旦某个线程调用notifyAll方法的话会一次性唤醒所有等待线程。</p>
<p>随机唤醒一个等待线程也很简单，线程只需要调用监视器对象的notify方法就可以唤醒在该对象上的一个等待线程，由于notify方法无法保证某个特定线程被唤醒，所以在这里被叫做随机唤醒线程。</p>
<p>有些时候我们需要唤醒特定的等待线程而不是随机唤醒，比如在某些情况下我们需要使等待线程以特定的顺序执行。为了实现这一点，每个线程需要在单独的监视器上调用wait方法，当通知线程需要唤醒某个特定的等待线程时，它只需要调用特定的监视器对象上的notify方法即可，在讲<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html" target="_blank" rel="external">Starvation and Fairness</a>时我们举过例子，这里不再复述。</p>
<p>下面这段代码块是第二种形式的Notification Strategy(随机唤醒一个等待线程),相关代码以注释标记:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      <span class="comment">//wait strategy - related to notification strategy</span></span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isLocked = <span class="keyword">false</span>;</span><br><span class="line">    notify(); <span class="comment">//notification strategy</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test_and_Set_Method">Test and Set Method</h3><p>同步块中一般有两种方法，其中一种是Test and Set方法，该方法首先通过Access Condition来test内部状态，如果判断通过线程将改变状态的值(set)来表示当前已经有线程获得了访问权限。</p>
<p>状态变换通常会使其他尝试获得访问权限的线程进行Access Condition时判断为false而阻塞，但也有例外，在Read/Write锁中，线程获得读权限的话将更新内部状态，但是其他线程依然可以获得该读权限，当然前提是此时没有写权限的请求。</p>
<p>还有一点非常重要，那就是Test And Set方法必须是原子方法，这意味着其他线程不允许在当前线程执行该方法时执行Test And Set方法。</p>
<p>Test And Set方法的内部流程如下所示：</p>
<ol>
<li>必要时先设置状态值</li>
<li>通过Acccess Condition判断状态</li>
<li>如果Access Condition为false，等待</li>
<li>如果Access Condition为true，设置状态新值，必要时唤醒其他线程</li>
</ol>
<p><a href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" target="_blank" rel="external">ReadWriteLock</a>中的lockWrite方法就是一个很典型的例子，该方法首先设置一个状态值(writeRequests++),随后调用canGrantWriteAccess方法，在该方法中的Access Condition判断状态，如果成功则状态会在lockWrite方法退出前被更新(writeRequests—;writeAccesses++)，注意到该方法并没有唤醒其他线程。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ReadWriteLock&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="keyword">Thread</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> readingThreads <span class="subst">=</span></span><br><span class="line">        <span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="keyword">Thread</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int writeAccesses    <span class="subst">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> int writeRequests    <span class="subst">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Thread</span> writingThread <span class="subst">=</span> <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> synchronized <span class="literal">void</span> lockWrite() throws InterruptedException&#123;</span><br><span class="line">        writeRequests<span class="subst">++</span>;</span><br><span class="line">        <span class="keyword">Thread</span> callingThread <span class="subst">=</span> <span class="keyword">Thread</span><span class="built_in">.</span>currentThread();</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span> canGrantWriteAccess(callingThread))&#123;</span><br><span class="line">        wait();</span><br><span class="line">        &#125;</span><br><span class="line">        writeRequests<span class="subst">--</span>;</span><br><span class="line">        writeAccesses<span class="subst">++</span>;</span><br><span class="line">        writingThread <span class="subst">=</span> callingThread;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set_Method">Set Method</h3><p>Set method是同步块中经常使用的第二种方法，该方法就是在同步块中直接修改状态的的值而不会事先判断它，一个典型的例子就是unlock方法，持有锁的线程总是可以调用unlock方法并且不用去管该对象是否已经被解锁过了。</p>
<p>Set Method的流程如下所示：</p>
<ol>
<li>更新状态</li>
<li>唤醒等待线程</li>
</ol>
<p>下面就是unlock方法的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">      isLocked = <span class="keyword">false</span>;</span><br><span class="line">      notify();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/11/译-java多线程与同步机制系列(26)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/11/译-java多线程与同步机制系列(26)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/10/译-java多线程与同步机制系列(25)/" title="[译]java多线程与同步机制系列(25)--比较并交换" itemprop="url">[译]java多线程与同步机制系列(25)--比较并交换</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-10T11:20:55.000Z" itemprop="datePublished"> 发表于 2015-05-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html</a>)</p>
<p>比较并交换(Compare and Swap)在设计同步算法时经常被用到。它是将某个变量的当前值与期望值比较，如果两者相等的话则赋给该变量一个新值。CAS听上去可能有点复杂，但是一旦我们理解了它的话就会觉得它很简单，下面我们来详细看一下这种技术。<br><br></p>
<h3 id="CAS的使用场景">CAS的使用场景</h3><p>在程序或同步算法中我们经常会见到这样一种模式：先检查再操作。这种模式经常发生在代码需要首先检查某个变量的值，然后基于这个变量做操作。下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!locked) &#123;</span><br><span class="line">            locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在多线程程序中使用这段代码时会发生很多错误，这里我们暂时忽略这些错误。</p>
<p>正如你看到的，lock方法首先将检查locked的值(先检查)，如果locked的值为false的话将该值改为true(再操作)。</p>
<p>如果多个线程访问这个MyLock对象的话lock方法就可能不会按照预定的方式执行了。比如说线程A检查了locked的值，此时locked为false，同时线程B也检查locked的值为false，那么线程A和线程B都将对locked变量进行操作。</p>
<p>为了能够在多线程程序中正常运行，“检查再操作”必须是原子性的。原子性意味着检查和操作必须作为一个不可分的代码块被执行。任何线程执行这段代码块都将不受其他线程干扰直到执行结束，另外没有其他线程可以同时执行这段代码。</p>
<p>下面这段实例代码中，我们对lock方法加上synchronized关键字使其变成原子性的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!locked) &#123;</span><br><span class="line">            locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在lock方法变成了同步方法，这意味着MyLock对象一次只允许一个线程访问，因此lock方法也就成为原子性的方法了。</p>
<p>lock方法就是一个典型的CAS的例子。该方法首先检查locked变量的值是不是等于期望值false，如果是，则给locked对象赋于新值true。<br><br></p>
<h3 id="CAS作为原子操作">CAS作为原子操作</h3><p>现代CPU都内置了对原子性的CAS的支持。从java5开始你就可以利用CPU的这种特性，方法就是创建java.util.cocurrent.atomic包中的原子类。</p>
<p>下面这段代码通过使用java5内置的AtomicBoolean类来实现上述的MyLock类：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> locked.<span class="title">compareAndSet</span><span class="params">(<span class="keyword">false</span>, <span class="keyword">true</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到locked变量不再是Boolean类型而是AtomicBoolean类。这个类有一个compareAndSet方法，该方法比较AtomicBoolean变量的值与一个期望值，如果相等则给该变量赋于一个新值。在这里，如果locked变量的值为false的话，则会赋给它一个新值true。</p>
<p>如果变量被赋于了新值，compareAndSet方法返回true，否则返回false。</p>
<p>使用java5提供的CAS特性而不是自己实现具有CAS特性的类的好处在于你可以充分利用CPU提供的CAS支持，这样会使得你的程序运行更快。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/10/译-java多线程与同步机制系列(25)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/10/译-java多线程与同步机制系列(25)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/10/译-java多线程与同步机制系列(24)/" title="[译]java多线程与同步机制系列(24)--线程池" itemprop="url">[译]java多线程与同步机制系列(24)--线程池</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-10T00:47:42.000Z" itemprop="datePublished"> 发表于 2015-05-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/thread-pools.html</a>)</p>
<p>当你需要限制程序中运行的线程数量的时候线程池就显得非常必要了。因为每启动一个线程都会有性能开销，都需要为其分配线程栈。</p>
<p>我们不会为每一个任务创建一个线程去执行它，相反，我们会把这个任务放到线程池中去，当线程池中有空闲线程的话就将这个任务交给该线程去执行。在线程池内部，任务都是存储在阻塞队列中，空闲线程也是从阻塞队列中直接获取任务执行。当一个新任务被加入阻塞队列中时，空闲线程将取出并运行该任务。而其他的空闲线程将一直阻塞直到有新的任务被加入阻塞队列。</p>
<p>线程池经常被用在多线程服务器中，服务器从网络接收到一个请求后一般会将该请求封装成一个任务放入线程池。线程池中的线程将同步执行这些连接请求。将来我会出一个教程专门讲解如何使用java构建一个多线程服务器。</p>
<p>java5的java.util.cocurrent包中内置了线程池的实现，所以我们没有必要自己写代码实现线程池。你可以在我的博客<a href="http://tutorials.jenkov.com/java-util-concurrent/executorservice.html" target="_blank" rel="external">java.util.concurrent.ExecutorService</a>中查看关于线程池的更多信息。在这里，我们有必要了解一下线程池背后的实现原理。</p>
<p>下面是一个简单的线程池的例子，请注意这里的BlockingQueue就是我们上一篇博客<a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html" target="_blank" rel="external">Blocking Queues</a>实现的阻塞队列。在实际开发中你可能会直接使用java内置的BlockingQueue类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue taskQueue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;PoolThread&gt; threads = <span class="keyword">new</span> ArrayList&lt;PoolThread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> noOfThreads, <span class="keyword">int</span> maxNoOfTasks)</span></span>&#123;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> BlockingQueue(maxNoOfTasks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;noOfThreads; i++)&#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> PoolThread(taskQueue));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(PoolThread thread : threads)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">execute</span><span class="params">(Runnable task)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isStopped) <span class="keyword">throw</span></span><br><span class="line">            <span class="keyword">new</span> IllegalStateException(<span class="string">"ThreadPool is stopped"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.taskQueue.enqueue(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(PoolThread thread : threads)&#123;</span><br><span class="line">           thread.doStop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue taskQueue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>       isStopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolThread</span><span class="params">(BlockingQueue queue)</span></span>&#123;</span><br><span class="line">        taskQueue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isStopped())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Runnable runnable = (Runnable) taskQueue.dequeue();</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//log or otherwise report exception,</span></span><br><span class="line">                <span class="comment">//but keep pool thread alive.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.interrupt(); <span class="comment">//break pool thread out of dequeue() call.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isStopped;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池的实现包括两个部分，一个是Thread Pool类作为线程池的公开接口，另一个则是继承了Thread类的PoolThread，用来执行任务。</p>
<p>当需要执行一个任务时，线程池调用execute方法，这里传入的参数是Runnable对象，该对象会保存到线程池的阻塞队列taskQueue中等待空闲线程将它取出并执行，空闲线程取出并执行任务的过程在PoolThread.run方法中定义，当其执行完该任务后会继续循环从阻塞队列中取出新的任务执行。</p>
<p>ThreadPool.stop方法用来停止线程池的执行。这个停止操作信号被存储在了内部的isStopped成员变量中，然后线程池的每个线程执行doStop方法。另外我们注意到当ThreadPool在stop方法后继续执行execute方法后会爬出IllegalStateException异常。</p>
<p>线程会在执行完当前任务后停止，注意到doStop方法中的interrupt方法，这个方法可以确保所有在taskQueue的dequeue方法上被阻塞的线程全部退出dequeue方法，它的实现原理是通过抛出一个InterupptedException异常，而这个异常随后在PoolThread.run方法中被捕获，记录，随后线程检查isStopped变量的值，由于此时isStopped的值为true，所以线程停止运行。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/10/译-java多线程与同步机制系列(24)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/10/译-java多线程与同步机制系列(24)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/09/译-java多线程与同步机制系列(23)/" title="[译]java多线程与同步机制系列(23)--阻塞队列" itemprop="url">[译]java多线程与同步机制系列(23)--阻塞队列</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-09T13:48:11.000Z" itemprop="datePublished"> 发表于 2015-05-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/blocking-queues.html</a>)</p>
<p>阻塞队列是一种很特殊的队列，当线程尝试从一个空的阻塞队列中获取数据或者向一个满的阻塞队列中放入数据时都会阻塞。线程从一个空阻塞队列中获取数据将阻塞直到其他线程向其中插入了数据，而线程向一个满的阻塞队列中放入数据也将阻塞直到其他线程从该队列中取出数据。</p>
<p>下面这张图显示了两个线程对同一个阻塞队列进行操作：</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png" alt="一个线程插入数据，一个线程取出数据"></p>
<p>java5的java.utl.cocurrent包提供了阻塞队列的实现，你可以在我的<a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="external">java.util.concurrent.BlockingQueue</a>这篇博客中查看关于该类的具体讲解。即使有了官方提供的实现类，我们依然有必要了解其背后运行的原理。</p>
<h3 id="阻塞队列的实现">阻塞队列的实现</h3><p>阻塞队列的实现有点像上一遍博客讲到的有限信号(BoundedSemaphore)。下面是一个简单的阻塞队列的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>  limit = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Object item)</span></span><br><span class="line">  throws InterruptedException  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.<span class="built_in">queue</span>.size() == <span class="keyword">this</span>.limit) &#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.<span class="built_in">queue</span>.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">queue</span>.add(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized Object <span class="title">dequeue</span><span class="params">()</span></span><br><span class="line">  throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.<span class="built_in">queue</span>.size() == <span class="number">0</span>)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.<span class="built_in">queue</span>.size() == <span class="keyword">this</span>.limit)&#123;</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">queue</span>.remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到notifyAll方法只有在队列为空或满的情况下才会调用。如果调用enqueue或者dequeue方法的时候队列不是满的或是空的，那么就不会有线程阻塞。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/09/译-java多线程与同步机制系列(23)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/09/译-java多线程与同步机制系列(23)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/09/译-java多线程与同步机制系列(22)/" title="[译]java多线程与同步机制系列(22)--信号" itemprop="url">[译]java多线程与同步机制系列(22)--信号</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-09T01:35:40.000Z" itemprop="datePublished"> 发表于 2015-05-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/semaphores.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/semaphores.html</a>)</p>
<p>信号是一种线程同步结构，它可以用来在线程间传递信号防止信号丢失或者像锁一样来守护临界区。java5的java.util.cocurrent包中提供了信号的实现，所以我们没有必要自己去写一个信号实现，但是我们仍然有必要了解其实现背后的原理。</p>
<p>上面提到java5中内置了信号的实现，所以开发者不需要自己实现信号，你可以在我的另外一个系列博客中查阅更多关于 java.util.concurrent.Semaphore的相关知识。<br><br></p>
<h3 id="一个简单的信号">一个简单的信号</h3><p>下面是一个简单的信号实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> signal = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.signal = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.signal) wait();</span><br><span class="line">    <span class="keyword">this</span>.signal = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take方法发送了一个信号保存在Semaphore内部，release方法等待该信号的到来，当收到了信号后，线程便清空信号并且退出release方法。</p>
<p>像上面这个Semaphore就可以防止信号丢失。在这里，线程调用的是take方法和release方法而不是直接调用notify或wait方法。如果take方法在release方法之前调用的话，那么调用release方法的线程仍然可以知道take方法已经被调用了，因为take方法发送的信号被存储在了Semaphore内部。而直接调用notify或wait方法就会出现问题。</p>
<p>take和release方法的方法名看上去可能有点奇怪，之所以取这两个名字是因为在这里我们把Semaphore当成了锁来看待，锁的获取称为take，释放称为release。这样取名更加形象。<br><br></p>
<h3 id="使用信号">使用信号</h3><p>下面是两个线程通过semaphore来发送信号的例子:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> semaphore = <span class="keyword">new</span> <span class="type">Semaphore</span><span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">SendingThread</span> sender = <span class="keyword">new</span> <span class="type">SendingThread</span>(semaphore);</span><br><span class="line"></span><br><span class="line"><span class="type">ReceivingThread</span> receiver = <span class="keyword">new</span> <span class="type">ReceivingThread</span>(semaphore);</span><br><span class="line"></span><br><span class="line">receiver.start<span class="literal">()</span>;</span><br><span class="line">sender.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendingThread</span> &#123;</span><br><span class="line">  Semaphore semaphore = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SendingThread</span><span class="params">(Semaphore semaphore)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="comment">//do something, then signal</span></span><br><span class="line">      <span class="keyword">this</span>.semaphore.take();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecevingThread</span> &#123;</span><br><span class="line">  Semaphore semaphore = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReceivingThread</span><span class="params">(Semaphore semaphore)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.semaphore.release();</span><br><span class="line">      <span class="comment">//receive signal, then do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="计数信号">计数信号</h3><p>上面的Semaphore类没有统计调用take方法而发送的信号次数。在这里我们希望其实现这个功能，所以对Semaphore类做了些许修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSemaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.signals++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</span><br><span class="line">    <span class="keyword">this</span>.signals--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="有限信号">有限信号</h3><p>上面的CountingSemophore没有限制该对象最多可以存储多少信号量，这里我们对代码再次做了些修改使其实现该功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bound = upperBound;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</span><br><span class="line">    <span class="keyword">this</span>.signals++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</span><br><span class="line">    <span class="keyword">this</span>.signals--;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出当信号量达到存储上界时，线程将阻塞直到其他线程调用release方法，随后该线程才会被唤醒重新传递信号。<br><br></p>
<h3 id="将信号用作锁">将信号用作锁</h3><p>可以将上面的BoundedSemaphore当成锁使用，这里我们只需要将bound值设为1即可。在临界区之前和之后分别调用take和release方法即可，下面是一个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BoundedSemaphore semaphore = <span class="keyword">new</span> BoundedSemaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">semaphore.take();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//critical section</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前只能有一个线程持有Semaphore的锁，其他线程调用take方法将阻塞直到当前执行线程调用release方法，而release方法永远都不会被阻塞，因为总会有一个线程在之前已经调用了take方法。</p>
<p>你也可以使用BoundedSemaphore来限制可以进入临界区的线程数量。比如说上面例子中把bound设置为5的话，五个线程将被同时允许进入临界区，但是你必须确保临界区中这五个线程的执行不会引发冲突，否则程序将发生异常。</p>
<p>最后注意一点，这里的release方法是在finally代码块中被调用的，这样一旦发生异常Semaphore对象的锁可以被及时释放。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/09/译-java多线程与同步机制系列(22)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/09/译-java多线程与同步机制系列(22)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/09/译-java多线程与同步机制系列(21)/" title="[译]java多线程与同步机制系列(21)--重入锁死" itemprop="url">[译]java多线程与同步机制系列(21)--重入锁死</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-09T00:37:20.000Z" itemprop="datePublished"> 发表于 2015-05-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/reentrance-lockout.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/reentrance-lockout.html</a>)</p>
<p>重入锁死与死锁，嵌套管程锁死的情况类似。在之前讲锁和读/写锁的时候也提到了这个问题。</p>
<p>当线程第二次进入非可重入的锁或者其他同步区域的时候会发生重入锁死问题。可重入意味着线程已经拥有了锁的情况下可以重复获取该锁。java的同步块是可重入的，像下面这段代码运行起来没有任何问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reentrant</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到outer方法和inner方法都是同步方法，也就相当于在方法内部都加了synchronized(this)同步块。如果一个线程调用outer方法的话，在outer方法内部继续调用inner方法是没有任何问题的，因为两个方法都是在同一个监视器上同步(synchronized(this))，所以线程获取了this对象的锁后，它可以继续执行所有对this对象加锁的同步块。这就叫做可重入，线程只要持有对象的锁就可以进入任何同步于该对象的代码块区域。</p>
<p>下面这个锁实现不是可重入的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isLocked = <span class="keyword">false</span>;</span><br><span class="line">    notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程连续两次调用lock方法的话，第二次调用将会使线程阻塞，这时就发生了重入锁死。</p>
<p>为了避免重入锁死，你有两个选择:</p>
<ol>
<li>避免写重复获取锁的代码</li>
<li>使用可重入锁</li>
</ol>
<p>你可以根据具体情况选择最适合的解决方案，可重入锁的效率比非可重入锁低，同时实现难度也很大，但是这也不是大问题。是否在你的代码中实现可重入锁，实现起来是否简单都取决于具体的项目。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/09/译-java多线程与同步机制系列(21)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/09/译-java多线程与同步机制系列(21)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/08/译-java多线程与同步机制系列(20)/" title="[译]java多线程与同步机制系列(20)--java读写锁" itemprop="url">[译]java多线程与同步机制系列(20)--java读写锁</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-08T00:42:33.000Z" itemprop="datePublished"> 发表于 2015-05-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/read-write-locks.html</a>)</p>
<p>读写锁是一种比上篇博客中提到的锁更加复杂的锁实现。想象一下你的应用需要对某些共享资源进行读写，并且读操作比写操作频繁的情况，两个线程读取同一个资源对双方都不会造成影响，所以多个线程可以同时对同一个资源进行读操作，但是如果一个线程需要对资源进行写操作，那么其他线程就无法对其进行读或者写操作。为了使得资源可以被多个资源同时读但是只允许一个线程写，就需要一个读写锁。</p>
<p>java5中java.util.concurrent包里为我们提供了读写锁的实现，我们可以在需要它的时候直接使用，但是了解其背后的实现原理对我们来说也是很有必要的。<br><br></p>
<h3 id="java中读写锁的实现">java中读写锁的实现</h3><p>首先我们总结一下获取资源读和写权限的情形：</p>
<ol>
<li>读权限： 没有线程获得该资源的写权限或者没有线程请求获得该资源的写权限</li>
<li>写权限： 没有线程获得该资源的读权限或者写权限</li>
</ol>
<p>如果一个线程想获得资源读权限，只要当前没有线程正在对资源进行写操作或者没有线程请求获得该资源的写权限的话，该线程可以成功获得读权限，在这里之所以优先考虑线程对资源的写权限请求是因为我们假设写操作比读操作更加重要。另外，如果读操作经常发生并且我们没有优先考虑写操作的话，就有可能发生饥饿。请求写操作权限的线程就一直阻塞直到所有读线程解锁该Lock对象。如果新的线程一直获取读权限的话，那么申请写权限的线程将一直阻塞导致饥饿。为了解决这个问题，线程只有在没有其他线程在执行写操作或者请求写操作权限的情况下才能获取该资源的读操作权限。</p>
<p>线程想要获取写权限的话必须保证没有其他线程正在对该资源进行读操作或者写操作。在这里，除非你希望在请求写权限的线程间保持公平性，否则我们不会理会到底有多少线程在请求写权限或者以什么顺序在请求获取写权限。</p>
<p>根据这些规则我们实现了一个ReadWriteLock锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> readers       = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> writers       = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> writeRequests = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(writers &gt; <span class="number">0</span> || writeRequests &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    readers++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readers--;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeRequests++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(readers &gt; <span class="number">0</span> || writers &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    writeRequests--;</span><br><span class="line">    writers++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writers--;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类有两个lock方法和两个unlock方法，其中一对lock方法和unlock方法是针对读权限，另一对则针对写权限。</p>
<p>lockRead方法实现中规定了读权限的获取规则：没有其他线程获取了写权限或者正在请求写权限。</p>
<p>lockWrite方法中规定了写权限的获取规则：一个线程想获取写权限的话，首先提出请求(writeRequests++),然后判断是否可以获取写权限，判断条件是没有其他线程持有读权限或者写权限，在这里没有考虑到底有多少线程在请求写权限。</p>
<p>这里有必要提一下为什么unlock方法中都用的是notifyAll方法而不是notify方法，请假设下面这种情况：<br>在ReadWriteLock对象上有多个线程在等待获取读权限，多个线程在等待获取写权限。如果一个等待获取读权限的线程被notify唤醒了，那么该线程又将进入等待状态因为此时有多个线程在等待写权限，那么这次notify等于没有任何效果，没有任何线程可以获得读权限或者写权限。所以这里我们使用notifyAll方法唤醒所有等待线程，这样总会有线程可以获取到它想要的权限。</p>
<p>使用notifyAll还有一个好处，当多个线程在等待读权限并且没有线程在等待写权限时，unlockWrite方法的调用会唤醒所有线程，那么等待读权限的线程可以同时获取读权限而不必一个接一个的被唤醒获取读权限。<br><br></p>
<h3 id="可重入的读写锁">可重入的读写锁</h3><p>上面这个ReadWriteLock锁的实现不是可重入的，如果一个已经持有写权限的线程再次请求写权限的话将陷入阻塞因为此时已经有一个线程获取了写权限，而这个线程就是它自己。另外我们再考虑以下这种情况：</p>
<ol>
<li>线程1持有读权限</li>
<li>线程2请求写权限但是被阻塞，因为此时线程1持有读权限</li>
<li>线程1再次请求读权限但是被阻塞，因为现在有一个线程2的写权限的请求。</li>
</ol>
<p>上面这种情况有点类似于死锁，此时没有任何线程可以获取读权限或者写权限。</p>
<p>为了让ReadWriteLock成为可重入的，我们需要对代码进行一些修改。我们将分开讨论针对读操作和写操作的可重入问题。<br><br></p>
<h3 id="读可重入">读可重入</h3><p>为了使ReadWriteLock对于读操作可重入，我们需要建立规则：一个线程可以获得可重入的读权限，当且仅当该线程可以获得读权限或者它本身已经持有读权限。</p>
<p>为了判断一个线程是否已经拥有了读权限，我们建立了一个Map对象保存了已经获取了读权限的线程以及它获取读权限的次数。当需要判断线程是否可以获取读权限时首先将从Map对象中获取该线程的引用。下面就是lockRead方法和unlockRead方法修改后的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> writers        = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> writeRequests  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! canGrantReadAccess(callingThread))&#123;</span><br><span class="line">      wait();                                                                   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readingThreads.put(callingThread,</span><br><span class="line">       (getAccessCount(callingThread) + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> accessCount = getAccessCount(callingThread);</span><br><span class="line">    <span class="keyword">if</span>(accessCount == <span class="number">1</span>)&#123; readingThreads.remove(callingThread); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; readingThreads.put(callingThread, (accessCount -<span class="number">1</span>)); &#125;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canGrantReadAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(writers &gt; <span class="number">0</span>)            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(isReader(callingThread) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(writeRequests &gt; <span class="number">0</span>)      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">getReadAccessCount</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    Integer accessCount = readingThreads.get(callingThread);</span><br><span class="line">    <span class="keyword">if</span>(accessCount == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> accessCount.<span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isReader</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.get(callingThread) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看到，如果当前没有线程持有写权限或者当前请求线程已经持有了读权限的话，此时该线程可以再次获取读权限，这样保证了读权限可重入。注意从canGrantReadAccess方法中可以看出，三个判断语句的顺序对可重入读权限的获取非常重要，尤其是第二个和第三个if语句，这样可以保证只要当前线程已经拥有了读权限的话，即使现在有其他线程的写权限请求，当前线程优先获得读权限。<br><br></p>
<h3 id="写可重入">写可重入</h3><p>写可重入的前提是当前线程已经获得了写权限，修改后的lockWrite方法和unlockWrite方法如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeRequests++;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! canGrantWriteAccess(callingThread))&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    writeRequests--;</span><br><span class="line">    writeAccesses++;</span><br><span class="line">    writingThread = callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeAccesses--;</span><br><span class="line">    <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</span><br><span class="line">      writingThread = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGrantWriteAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hasReaders())             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(writingThread == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isWriter(callingThread)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWriter</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writingThread == callingThread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到判断当前线程是否可以获取可重入写权限时当前线程是否持有写权限被纳入考虑范围。<br><br></p>
<h3 id="读到写可重入">读到写可重入</h3><p>有时候需要让一个拥有读权限的线程可以获取写权限，为了达到这个目的，首先该线程必须是唯一一个读线程。我们对writeLock方法进行了一下修改使得可以做到读到写可重入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeRequests++;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! canGrantWriteAccess(callingThread))&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    writeRequests--;</span><br><span class="line">    writeAccesses++;</span><br><span class="line">    writingThread = callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeAccesses--;</span><br><span class="line">    <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</span><br><span class="line">      writingThread = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGrantWriteAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isOnlyReader(callingThread))    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(hasReaders())                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(writingThread == <span class="keyword">null</span>)          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isWriter(callingThread))       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWriter</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writingThread == callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOnlyReader</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> readingThreads.size() == <span class="number">1</span> &amp;&amp; readingThreads.get(callingThread) != <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这个ReadWriteLock类就支持读到写可重入了。<br><br></p>
<h3 id="写到读可重入">写到读可重入</h3><p>有时候需要一个拥有写权限的线程可以获取读权限，只要该线程需要读权限的话可以毫不犹豫的给它权限，因为拥有写权限意味着其他线程无法获取读权限或者写权限，因此这个时候再给该线程读权限是没有任何问题的。对此我们只需要将canGrantReadAccess方法改写一下即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGrantReadAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isWriter(callingThread)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(writingThread != <span class="keyword">null</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(isReader(callingThread)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(writeRequests &gt; <span class="number">0</span>)       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="完整的可重入锁">完整的可重入锁</h3><p>下面是一个完整的可重入锁的实现，我重写了一些判断条件使得代码更易于阅读。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</span><br><span class="line">       <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! canGrantReadAccess(callingThread))&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readingThreads.put(callingThread,</span><br><span class="line">     (getReadAccessCount(callingThread) + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canGrantReadAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( isWriter(callingThread) ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( hasWriter()             ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( isReader(callingThread) ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( hasWriteRequests()      ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span>(!isReader(callingThread))&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Calling Thread does not"</span> +</span><br><span class="line">        <span class="string">" hold a read lock on this ReadWriteLock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> accessCount = getReadAccessCount(callingThread);</span><br><span class="line">    <span class="keyword">if</span>(accessCount == <span class="number">1</span>)&#123; readingThreads.remove(callingThread); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; readingThreads.put(callingThread, (accessCount -<span class="number">1</span>)); &#125;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    writeRequests++;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! canGrantWriteAccess(callingThread))&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    writeRequests--;</span><br><span class="line">    writeAccesses++;</span><br><span class="line">    writingThread = callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isWriter(Thread.currentThread())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Calling Thread does not"</span> +</span><br><span class="line">        <span class="string">" hold the write lock on this ReadWriteLock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    writeAccesses--;</span><br><span class="line">    <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</span><br><span class="line">      writingThread = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canGrantWriteAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isOnlyReader(callingThread))    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(hasReaders())                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(writingThread == <span class="keyword">null</span>)          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isWriter(callingThread))       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">getReadAccessCount</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    Integer accessCount = readingThreads.get(callingThread);</span><br><span class="line">    <span class="keyword">if</span>(accessCount == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> accessCount.<span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasReaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isReader</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.get(callingThread) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isOnlyReader</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readingThreads.size() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">           readingThreads.get(callingThread) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writingThread != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isWriter</span><span class="params">(Thread callingThread)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writingThread == callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasWriteRequests</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.writeRequests &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="在finally代码块中调用unlock方法">在finally代码块中调用unlock方法</h3><p>当用ReadWriteLock守护临界区时，临界区可能会抛出异常，那么就有必要在finally代码快中调用readUnlock和writeUnlock方法。这样可以确保ReadWriteLock对象一定可以被解锁而使其他线程可以给它上锁。代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">lock</span>.lockWrite();</span></span><br><span class="line">try&#123;</span><br><span class="line">  //<span class="operator"><span class="keyword">do</span> critical <span class="keyword">section</span> code, which may throw <span class="keyword">exception</span></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  <span class="keyword">lock</span>.unlockWrite();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finally块可以确保ReadwriteLock对象的锁被及时释放即使临界区抛出异常。如果unlock方法没有放在finally代码块中的话，一旦异常发生，锁没有被即使释放的话就会造成调用readLock或writeLock的线程一直阻塞，现在假设unlock方法没有放在finally代码快中并且发生了异常，那么现在唯一可以对ReadWriteLock对象解锁的方法就是依靠发生异常时持有该对象锁的线程重新调用lockWrite方法(针对上面的代码)，然后执行临界区代码，最后调用unlockWrite方法解锁，同时这还得依靠ReadWriteLock的可重入性。与其让我们等待该线程重新调用lockWrite方法，倒不如将unlockWrite方法放到finally代码块中去执行，这是一种更加健壮的解决方案。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/08/译-java多线程与同步机制系列(20)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/08/译-java多线程与同步机制系列(20)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/07/译-java多线程与同步机制系列(19)/" title="[译]java多线程与同步机制系列(19)--java中的锁" itemprop="url">[译]java多线程与同步机制系列(19)--java中的锁</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱家骅" target="_blank" itemprop="author">朱家骅</a>
		
  <p class="article-time">
    <time datetime="2015-05-07T00:25:36.000Z" itemprop="datePublished"> 发表于 2015-05-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文链接(<a href="http://tutorials.jenkov.com/java-concurrency/locks.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/locks.html</a>)</p>
<p>Java中的锁是一种和同步块类似的同步机制，不同的地方在于锁比同步块更加复杂。当然，锁也是由同步块来实现的，所以我们自始至终都离不开synchronized关键字。</p>
<p>从java5开始，java.utl.concurrent.locks包中就包含了很多种锁的实现，所以你可能不需要自己手写一个锁，但是你需要知道怎么用这些官方提供的锁，同时也应该了解这些锁的运行原理。如果你想了解更多关于这些锁的信息，可以查看我得其他教程，链接如下：</p>
<p>java.util.concurrent.locks.Lock interface教程(<a href="http://tutorials.jenkov.com/java-util-concurrent/lock.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-util-concurrent/lock.html</a>)<br><br></p>
<h3 id="一个简单的锁实现">一个简单的锁实现</h3><p>首先我们来看一看java同步块的代码:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> inc()&#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> ++<span class="keyword">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inc方法中有一个synchronized(this)同步块，这个同步块保证只能有一个线程可以执行return ++count操作。同步块中的代码可以更复杂，但是这里++count足够表明我们的意思。</p>
<p>Counter类也可以写成下面这种形式，这里我们使用Lock类而不是同步块：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Counter</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> Lock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">int</span> newCount = ++count;</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">    <span class="keyword">return</span> newCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock方法将使当前线程获得Lock对象的锁，所以其他线程调用lock方法将被阻塞直到当前线程调用unlock方法释放锁。</p>
<p>下面是一个Lock类的简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isLocked = <span class="keyword">false</span>;</span><br><span class="line">    notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock方法中有一个while(isLocked)循环，也叫做自旋锁，关于自旋锁和wait，notify方法的相关知识我们在前面文章中都有描述，这里不再做过多阐述，当isLocked为true，那么调用lock方法的线程都将调用wait方法进入等待状态。为了防止等待线程在没有收到notify方法发送的信号而自动被唤醒(虚假唤醒)，我们在这里需要反复查看isLocked的状态来确保程序能正常执行。如果isLocked为false，那么线程将退出while循环，将isLocked设置为true，同时锁住Lock对象以阻塞其他线程。</p>
<p>当线程执行完临界区的代码(临界区就是lock与unlock方法之间的代码)，线程调用unlock方法，此时isLocked为false，在该Lock对象上被阻塞的线程将被唤醒继续执行lock方法。<br><br></p>
<h3 id="可重入锁">可重入锁</h3><p>java中的同步块是可重入的。意思是线程进入一个同步块中，那么它就获得了该同步块所作用的监视器对象的锁，那么这个线程就可以继续进入其他同样作用于该监视器对象的同步块中，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reentrant</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outer和inner方法都是同步方法，相当于两个synchronized(this)同步块。如果一个线程调用outer方法进入同步块中，随后继续调用inner方法的话是没有任何问题的，因为两个同步块都是对this对象起作用。总之，如果一个线程持有一个监视器对象的锁，那么它就可以进入所有作用于该监视器对象的同步块，这就叫做重入，线程可以重入所有作用于该线程所持有锁的对象的所有同步块。</p>
<p>上面的Lock类不是可重入的，下面我们重写了一个Reentant类，那么使用这个类的话，outer()中调用inner()将会在inner()中lock.lock<br>()处阻塞。代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Reentrant2&#123;</span><br><span class="line"></span><br><span class="line">  <span class="operator"><span class="keyword">Lock</span> <span class="keyword">lock</span> = new <span class="keyword">Lock</span>();</span></span><br><span class="line"></span><br><span class="line">  public outer()&#123;</span><br><span class="line">    <span class="operator"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span></span><br><span class="line">    inner();</span><br><span class="line">    <span class="operator"><span class="keyword">lock</span>.<span class="keyword">unlock</span>();</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized inner()&#123;</span><br><span class="line">    <span class="operator"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span></span><br><span class="line">    //<span class="operator"><span class="keyword">do</span> something</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">unlock</span>();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程首先调用outer方法将获得Lock对象的锁，然后它调用inner方法。在inner方法中，该线程将再次尝试获取Lock对象的锁，这将会使线程阻塞，因为Lock对象的锁已经在outer方法中被该线程获取了。</p>
<p>线程将阻塞的原因是我们没有在调用inner方法前调用lock.unlock()释放锁，当我们再次查看Lock类的源码就会发现问题所在了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while()循环中有一个条件判断是否线程被允许退出lock方法，只有当isLocked为false时才允许线程退出lock方法，在这里我们不会留意是哪个线程获得了该对象的锁，这就是问题所在了。</p>
<p>为了使上面的Lock类可重入，我们需要做一些改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">  Thread  lockedBy = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">int</span>     lockedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread callingThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(isLocked &amp;&amp; lockedBy != callingThread)&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>;</span><br><span class="line">    lockedCount++;</span><br><span class="line">    lockedBy = callingThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.curentThread() == <span class="keyword">this</span>.lockedBy)&#123;</span><br><span class="line">      lockedCount--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(lockedCount == <span class="number">0</span>)&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在while循环也将考虑当前持有该对象的锁的线程。当isLocked为false或者当前线程就是持有该对象的锁的线程时，线程将不会等待而是继续执行最后退出lock方法。</p>
<p>同时我们也需要记录该对象的锁被线程获取的次数，否则一次unlock就会释放该对象的锁，即使这个锁被获取了多次。我们希望的是线程调用了多少次lock方法上锁就需要调用多少次unlock来解锁。</p>
<p>现在这个Lock类就是可重入的了。<br><br></p>
<h3 id="公平锁">公平锁</h3><p>java的同步块没有确保线程获取锁的顺序。因此如果有多个线程同时竞争一个对象的锁的话，就有可能有一个或多个线程永远无法获取该对象的锁，这就是我们提过的饥饿。本文中的Lock类都是使用的同步块机制，所以它也无法保证公平性。为了保证公平性，我们可以到饥饿与公平那篇博客中去找到方法。<br><br></p>
<h3 id="在finally代码块中调用unlock方法">在finally代码块中调用unlock方法</h3><p>当我们使用Lock类来守护临界区时，临界区可能会抛出异常，那么这个时候我们就非常有必要在finally代码块中调用unlock来释放对象的锁了，这样其他线程可以获取该对象的锁继续运行。下面是一个例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span></span><br><span class="line">try&#123;</span><br><span class="line">  //<span class="operator"><span class="keyword">do</span> critical <span class="keyword">section</span> code, which may throw <span class="keyword">exception</span></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  <span class="keyword">lock</span>.<span class="keyword">unlock</span>();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很简短的代码块保证了当临界区发生异常时Lock对象的锁能被及时释放。如果unlock方法不是在finally块中被调用，那么一旦发生异常，那么Lock对象将被永久锁定，其他线程将永远无法获得Lock对象的锁。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/07/译-java多线程与同步机制系列(19)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/07/译-java多线程与同步机制系列(19)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">13</span></li></ul>
  </div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Java多线程/" title="Java多线程">Java多线程<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/maven/" title="maven">maven<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://www.csdn.net" target="_blank" title="CSDN">CSDN</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1685825420&verifier=f33b37d3&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 大家好，我是朱家骅。 <br/>
			欢迎来到我的技术博客！！！</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1685825420" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:317560406@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="朱家骅">朱家骅</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"flash03"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
